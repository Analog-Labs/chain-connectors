use core::{
    fmt::Display,
    pin::Pin,
    task::{Context, Poll},
};
use std::fmt::Debug;
// use derivative::Derivative;
pub use parity_scale_codec::{Decode, Encode};

/// Possible transaction statuses returned from our [`TxProgress::next()`] call.
// #[derive(Derivative)]
// #[derivative(Debug(bound = "ID: core::fmt::Debug"))]
#[derive(Debug, PartialEq, Eq)]
pub enum TxStatus<ID: Debug + PartialEq + Eq> {
    /// Transaction is part of the future queue.
    Validated,
    /// The transaction has been broadcast to other nodes.
    Broadcasted,
    /// Transaction is no longer in a best block.
    NoLongerInBestBlock,
    /// Transaction has been included in block with given hash.
    InBestBlock(ID),
    /// Transaction has been finalized by a finality-gadget, e.g GRANDPA
    InFinalizedBlock(ID),
    /// Something went wrong in the node.
    Error {
        /// Human readable message; what went wrong.
        message: String,
    },
    /// Transaction is invalid (bad nonce, signature etc).
    Invalid {
        /// Human readable message; why was it invalid.
        message: String,
    },
    /// The transaction was dropped.
    Dropped {
        /// Human readable message; why was it dropped.
        message: String,
    },
}

/// Event generated by the `Client`.
#[derive(Debug)]
pub enum ClientEvent<T: Client> {
    /// Event generated by the Client
    Notify(<T::Config as Config>::Event),

    /// Informs that the tx status was updated
    TxStatus { id: T::TransactionId, status: TxStatus<<T::Config as Config>::BlockIdentifier> },

    /// Query Result
    Query { id: T::QueryId, result: Result<<T::Config as Config>::QueryResult, T::Error> },

    /// Close the connection for the given reason.
    Close(T::Error),
}

// Client Primitives
pub trait Config {
    type Transaction: Encode + Decode + Debug + PartialEq + Eq + Clone + Send + Sync + 'static;
    type TransactionIdentifier: ToString + Debug + Display + PartialEq + Eq + Clone + 'static;

    type Block: Debug + PartialEq + Eq + Clone + Send + Sync;
    type BlockIdentifier: Sized + Debug + Display + PartialEq + Eq + Clone + Send + Sync;

    type Query: Sized + Debug + Clone + Encode + Decode + Send + Sync + PartialEq + Eq + 'static;
    type QueryResult: Sized + Debug + Encode + Clone + PartialEq + Eq + Send + Sync + 'static;

    type Event: Debug + PartialEq + Eq + Clone;
}

pub trait Client: Sized {
    type Config: Config;
    type TransactionId: Debug;
    type QueryId: Debug;
    type Error: std::error::Error;

    /// Submits a signed transaction
    /// # Errors
    /// Should return `Err` if the transaction is invalid
    fn submit(
        &mut self,
        tx: <Self::Config as Config>::Transaction,
    ) -> Result<Self::TransactionId, Self::Error>;

    /// Query some read-only data
    /// # Errors
    /// Should return `Err` if the query is invalid
    fn query(
        &mut self,
        query: <Self::Config as Config>::Query,
    ) -> Result<Self::QueryId, Self::Error>;

    /// Should behave like `Stream::poll()`.
    fn poll_next_event<'a, 'b, 'c, 'd: 'a>(
        self: Pin<&'a mut Self>,
        cx: &'b mut Context<'c>,
    ) -> Poll<ClientEvent<Self>>
    where
        Self: 'd;
    // fn poll_next_event(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<ClientEvent<Self>>;
    // fn poll_next_event<'a: 'b, 'b, 'c: 'a, 'd>(self: Pin<&'b mut Self>, cx: &'d mut Context<'c>)
    // -> Poll<ClientEvent<Self>> where Self: 'a;
}

// pub trait Query {
//     type Result: Sized;
// }

// pub trait Transaction: Sized {
//     type ID: 'static + Send + Sync + Sized + Clone + PartialEq + Eq + Display;
//     type DecodeError: Display;

//     fn id(&self) -> Self::ID;
// }

// pub trait Client2 {
//     type Transaction: Transaction;
//     type Subscription;
//     type Query;
//     type QueryResult;
//     type Event;
//     type Error: std::error::Error;

//     type ClientEvent = ClientEvent<
//         Self::Event,
//         Self::TransactionId,
//         Self::QueryId,
//         Result<Self::QueryResult, Self::Error>,
//         Self::

//     type SubmitTransactionFuture<'a>: Future<Output = Result<Self::TransactionId, Self::Error>> +
// 'a + Send + Unpin where Self: 'a;     type QueryFuture<'a>: Future<Output = Result<<Self::Query
// as Query>::Result, Self::Error>> + 'a + Send + Unpin where Self: 'a;

//     /// Submits a signed transaction
//     /// # Errors
//     /// Should return `Err` if the transaction is invalid
//     fn submit<'a>(
//         &'a self,
//         tx: <Self::Config as Config>::Transaction,
//     ) -> Self::SubmitTransactionFuture<'a>;

//     /// Submits a signed transaction
//     /// # Errors
//     /// Should return `Err` if the transaction is invalid
//     fn subscribe<'a>(
//         &'a self,
//         tx: <Self::Config as Config>::Transaction,
//     ) -> Self::SubmitTransactionFuture<'a>;

//     /// Query some read-only data
//     /// # Errors
//     /// Should return `Err` if the query is invalid
//     fn query<'a>(
//         &'a self,
//         query: Self::Query,
//     ) -> Self::QueryFuture<'a>;

//     /// Should behave like `Stream::poll()`.
//     fn poll_next_event(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<ClientEvent<Self>>;
// }
